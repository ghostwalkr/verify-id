# verify-id
A simple ID verification system

## Description
This tool lets two or more parties securely identify each other without giving up any potentially identifiable info. It's designed to be hard to fake your identity or copy someone else's identity (if implemented properly). It's still a work in progress, and there may be logic holes in it.

## How it works
TLDR; The system uses crytography (SHA512), variable publicly known variables, and various psudorandom values to make a unique hash and timestamp that can be used to identify other people over an untrusted platform.

The concept is that two parties can securely identify each other without giving up anything useful to people who could be eavesdropping or people that could want to copy the identity of one of the parties. Let's look at two people named bob and sue. Bob and sue want to communicate with each other over IRC without a) using identifiable usernames b) anyone else being able to copy either of their IDs or c) anyone else being able to identify either of them. Bob uses the id.sh script to generate a fingerprint hash and timestamp that looks something like this: `Timestamp: 09361721022020 2fdb197ebe3e73271df2700e1d290ce78393d01968d7abddf4944aca6471a9dbe9bc391b5fffd362c2b20f83d9fa3180183239f2c47d8e6c0ed982ac86b0cd8f`. He sends this to Sue over IRC in a public channel. Sue uses the id.sh script to verify the hash and timestamp. Sue then does the same to identify herself.
 There are a few possible attacks on this. One such possible threat is someone could simply copy the timestamp and hash and use it later to "identify" themselves as either bob or sue. Once a hash/timestamp combo is used, it is invalid. The tool doesn't keep a record of used hashes yet, but I'll implement that soon. So any reused hash/timestamp combos can be assumed to be someone trying to impersonate bob or sue. The other main attack is an attacker learning how to make an ID hash/timestamp combo that is valid. The hash/timestamp combo is generated by getting the time (in a specific UTC format), a "secret string" (which could be a username if you want to id some person, or it could be a passphrase of some kind), and optionally a random word from a list of words. These values are combined and then hashed using SHA512. So to verify the hash is legitimate you simply put in the timestamp, secret string, and random word from the list and hash the resulting string. The two parties will have previously agreed upon the time format, secret string, and wordlist (if used). The time and random word ensures that the hash will always be different. The only weakness (that I've found) is the process of agreeing on the variables ahead of time. If an attacker listens in on this, the system is a lot weaker (depending on the wordlist and whether the secret string is captured or not).
 The overall system can be modified to be stronger, or implemented in different ways. You could make the wordlist longer, switch up the order of variables, add multiple wordlists (although this would make verification take longer and use more computer resources), or add in other variables to make figuring out how to make a ID hash/timestamp harder. It's intended to be simple to use, but effective.
 
 ## Key to keeping this secure
 Make sure nobody but the trusted parties know how to generate a hash. Because if you know how to make a hash/timestamp combo and all the variables needed, you can impersonate anyone else who uses the same hash creation method.
 
 ## Tool installation/usage
 One liner to install: `git clone https://github.com/ghostwalkr/verify-id; if test `hash sha512sum; echo $?` != 0; then echo "sha512sum not found. please install it."; exit; else cd verify-id; chmod 700 id.sh`
 1. `$ git clone https://github.com/ghostwalkr/verify-id`
 2. `$ cd verify-id`
 3. `$ chmod 700 verify-id`
 4. `$ ./id.sh <option>`
